# FDN Reverb - High-Performance Audio Reverb Processor

A fast Feedback Delay Network (FDN) reverb implementation using PyTorch, with optional C++ extensions for maximum performance. Processes a 2 minutes 48khz stereo song in ~2.4 seconds on M4 MacBook Pro!


## Technical Details

If you are interested in more details, please read my [blog](https://puar-playground.github.io/posts/reverb/): ğŸµ FDN Reverb - Ripples of Space and Time.


## Features

- ğŸš€ **High Performance**: C++ extension for > 100x speedup over pure Python
- ğŸ›ï¸ **Cross-Platform**: Works on CPU (Mac, Linux, Windows)
- ğŸµ **Multi-Format Support**: Load/save MP3, WAV, and other audio formats
- ğŸšï¸ **Flexible Parameters**: Adjustable feedback gain, damping, wet/dry mix, and modulation
- ğŸ”Š **Automatic Volume Matching**: Peak-based normalization to match input/output levels
- ğŸ§ **Stereo Support**: Process mono or stereo audio with batch processing

## Quick Start

**Note**: The default input file `dry.mp3` is generated by [Suno AI](https://suno.ai), and `wet_fdn.mp3` is the output processed with default parameters.

### Command-Line Usage

```bash
# Basic usage with default parameters
python main.py

# Custom input/output files
python main.py -i input.mp3 -o output.mp3

# Adjust reverb parameters
python main.py --feedback_gain 0.95 --wet 0.8 --damp 0.3

# Custom delay times
python main.py --delays_ms 20 30 40 50 60 70 80 90

# See all options
python main.py --help
```

### Python API Usage

```python
import torch
from reverb_util import FDNReverb
from io_utils import save_audio, load_audio

# Load audio
audio, sr = load_audio("input.mp3", mono=False, target_sample_rate=None)

# Create reverb
reverb = FDNReverb(
    sr=sr,
    delays_ms=(29, 37, 43, 53, 61, 71, 79, 89),
    feedback_gain=0.9,
    damp=0.25,
    wet=0.9,
    mod_depth_ms=0.5,
    mod_rate_hz=0.3
)

# Process audio
wet = reverb.process(audio)

# Save output
save_audio(wet, sample_rate=sr, file_path="output.mp3")
```

## Installation

### Requirements

- PyTorch and torchaudio
- FFmpeg (for MP3 support)

### Install Dependencies

```bash
pip install torch torchaudio
```

**Note**: For MP3 support, you may need to install FFmpeg:
- **macOS**: `brew install ffmpeg`
- **Linux**: `sudo apt-get install ffmpeg`
- **Windows**: Download from [ffmpeg.org](https://ffmpeg.org/)

## Usage

### Command-Line Options

#### Input/Output
- `--input`, `-i`: Input audio file path (default: `dry.mp3`)
- `--output`, `-o`: Output audio file path (default: `wet_fdn.mp3`)
- `--mono`: Convert input to mono (default: stereo)
- `--target_sample_rate`: Resample to target sample rate (default: preserve original)

#### Reverb Parameters
- `--delays_ms`: Delay times in milliseconds, space-separated (default: `29 37 43 53 61 71 79 89`)
- `--feedback_gain`: Feedback gain 0~1, larger = longer tail, must be <1 (default: `0.9`)
- `--damp`: Damping factor 0~1, larger = faster high-frequency decay (default: `0.25`)
- `--wet`: Wet/dry mix ratio 0~1, 0=dry, 1=fully wet (default: `0.9`)
- `--mod_depth_ms`: Modulation depth in milliseconds (default: `0.5`)
- `--mod_rate_hz`: Modulation rate in Hz (default: `0.3`)
- `--output_gain`: Output gain scaling factor (default: `1.0`)

#### Other Options
- `--no_volume_match`: Disable automatic volume matching between input and output

### Example Commands

```bash
# Quick processing with defaults
python main.py -i song.mp3 -o reverb_song.mp3

# Create a longer, more pronounced reverb
python main.py --feedback_gain 0.95 --wet 0.9 --damp 0.2

# Short, subtle reverb
python main.py --feedback_gain 0.7 --wet 0.3 --damp 0.4

# Custom delay configuration
python main.py --delays_ms 15 23 31 47 59 67 73 83
```

## Parameters

### FDNReverb Parameters

- `sr` (int): Sample rate in Hz
- `delays_ms` (tuple): Delay times in milliseconds. Use coprime/prime numbers for better diffusion
- `feedback_gain` (float, 0~1): Feedback gain. Larger values = longer reverb tail. Must be < 1.0
- `damp` (float, 0~1): Damping factor. Larger values = faster high-frequency decay
- `wet` (float, 0~1): Wet/dry mix ratio (0 = dry, 1 = fully wet)
- `mod_depth_ms` (float): Modulation depth in milliseconds. Light modulation avoids metallic artifacts
- `mod_rate_hz` (float): Modulation rate in Hz
- `output_gain` (float): Output gain scaling factor (default: 1.0)

### Number of Delay Lines

**Important Constraint**: The number of delay lines must be a **power of 2** (2, 4, 8, 16, 32, 64, etc.) because the Hadamard feedback matrix requires this. The default is **8 delay lines**.

**What happens if you add more delay lines?**

**Pros:**
- âœ… **Richer, more complex reverb** - More delay lines create better diffusion and more echo paths
- âœ… **Better spatial spread** - More paths for sound to travel through
- âœ… **More realistic tails** - Denser echo patterns sound more natural

**Cons:**
- âš ï¸ **Slower processing** - Feedback matrix multiplication is O(NÂ²), so 16 lines is ~4x slower than 8
- âš ï¸ **More memory** - Each delay line needs its own buffer
- âš ï¸ **Diminishing returns** - Beyond 16 lines, the improvement is often minimal

**Performance Impact:**
- **8 lines** (default): Baseline speed
- **16 lines**: ~2x slower
- **32 lines**: ~4x slower  
- **64 lines**: ~8x slower

**Recommendations:**
- **8 lines**: Good balance of quality and speed (default)
- **16 lines**: Richer reverb, ~2x slower - good for final mixes
- **32+ lines**: Usually not worth the slowdown unless you need maximum quality

**Example with 16 delay lines:**
```bash
python main.py --delays_ms 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83
```

**Note**: The code will raise an error if you provide a number of delay times that is not a power of 2.

## Performance

### Automatic Optimization

The code automatically tries to use the fastest available implementation:

1. **CPU C++ Extension**: Fast compiled C++ code, works on all platforms (auto-compiles on first run)
2. **Python Fallback**: Pure PyTorch implementation (slower but always works)

### Expected Performance

- **With C++ Extension**: 5-20x faster than Python
- **Processing Time** (tested on M4 MacBook Pro, CPU-only):
  - ~2.4 seconds for a 2-minute stereo song (with C++ extension)
  - ~1.2 seconds per minute of audio (approximately)
  - Python fallback is significantly slower (10-20x slower)

**Note**: FDN reverb is inherently sequential due to feedback loops, so each sample depends on previous samples. This provides unique sonic characteristics.

### Performance Tips

1. **Use C++ Extension**: The code automatically compiles and uses C++ extensions on first run
2. **Lower Sample Rate**: Processing at 44.1kHz instead of 48kHz is ~10% faster
3. **Adjust Block Size**: For very long files, consider processing in chunks


## File Structure

```
Reverb/
â”œâ”€â”€ main.py              # Command-line interface and example usage script
â”œâ”€â”€ reverb_util.py       # Main FDN reverb implementation
â”œâ”€â”€ io_utils.py          # Audio I/O utilities (load/save MP3, WAV, etc.)
â”œâ”€â”€ fdn_cpu.cpp          # CPU C++ extension (optional, auto-compiles)\
â””â”€â”€ README.md           # This file
```


## Reference

```
@inproceedings{jot1991digital,
  title={Digital delay networks for designing artificial reverberators},
  author={Jot, Jean-Marc and Chaigne, Antoine},
  booktitle={Audio Engineering Society Convention 90},
  year={1991},
  organization={Audio Engineering Society}
}
```

# FDN Reverb - High-Performance Audio Reverb Processor

A fast Feedback Delay Network (FDN) reverb implementation using PyTorch, with optional C++ extensions for maximum performance. Processes a 2:00 stereo song in ~2.4 seconds on M4 MacBook Pro!

## Features

- üöÄ **High Performance**: C++ extension for 5-20x speedup over pure Python
- üéõÔ∏è **Cross-Platform**: Works on CPU (Mac, Linux, Windows)
- üéµ **Multi-Format Support**: Load/save MP3, WAV, and other audio formats
- üéöÔ∏è **Flexible Parameters**: Adjustable feedback gain, damping, wet/dry mix, and modulation
- üîä **Automatic Volume Matching**: Peak-based normalization to match input/output levels
- üéß **Stereo Support**: Process mono or stereo audio with batch processing

## Quick Start

**Note**: The default input file `dry.mp3` is generated by [Suno AI](https://suno.ai), and `wet_fdn.mp3` is the output processed with default parameters.

### Command-Line Usage

```bash
# Basic usage with default parameters
python main.py

# Custom input/output files
python main.py -i input.mp3 -o output.mp3

# Adjust reverb parameters
python main.py --feedback_gain 0.95 --wet 0.8 --damp 0.3

# Custom delay times
python main.py --delays_ms 20 30 40 50 60 70 80 90

# See all options
python main.py --help
```

### Python API Usage

```python
import torch
from reverb_util import FDNReverb
from io_utils import save_audio, load_audio

# Load audio
audio, sr = load_audio("input.mp3", mono=False, target_sample_rate=None)

# Create reverb
reverb = FDNReverb(
    sr=sr,
    delays_ms=(29, 37, 43, 53, 61, 71, 79, 89),
    feedback_gain=0.9,
    damp=0.25,
    wet=0.9,
    mod_depth_ms=0.5,
    mod_rate_hz=0.3
)

# Process audio
wet = reverb.process(audio)

# Save output
save_audio(wet, sample_rate=sr, file_path="output.mp3")
```

## Installation

### Requirements

- PyTorch and torchaudio
- FFmpeg (for MP3 support)

### Install Dependencies

```bash
pip install torch torchaudio
```

**Note**: For MP3 support, you may need to install FFmpeg:
- **macOS**: `brew install ffmpeg`
- **Linux**: `sudo apt-get install ffmpeg`
- **Windows**: Download from [ffmpeg.org](https://ffmpeg.org/)

## Usage

### Command-Line Options

#### Input/Output
- `--input`, `-i`: Input audio file path (default: `dry.mp3`)
- `--output`, `-o`: Output audio file path (default: `wet_fdn.mp3`)
- `--mono`: Convert input to mono (default: stereo)
- `--target_sample_rate`: Resample to target sample rate (default: preserve original)

#### Reverb Parameters
- `--delays_ms`: Delay times in milliseconds, space-separated (default: `29 37 43 53 61 71 79 89`)
- `--feedback_gain`: Feedback gain 0~1, larger = longer tail, must be <1 (default: `0.9`)
- `--damp`: Damping factor 0~1, larger = faster high-frequency decay (default: `0.25`)
- `--wet`: Wet/dry mix ratio 0~1, 0=dry, 1=fully wet (default: `0.9`)
- `--mod_depth_ms`: Modulation depth in milliseconds (default: `0.5`)
- `--mod_rate_hz`: Modulation rate in Hz (default: `0.3`)
- `--output_gain`: Output gain scaling factor (default: `1.0`)

#### Other Options
- `--no_volume_match`: Disable automatic volume matching between input and output

### Example Commands

```bash
# Quick processing with defaults
python main.py -i song.mp3 -o reverb_song.mp3

# Create a longer, more pronounced reverb
python main.py --feedback_gain 0.95 --wet 0.9 --damp 0.2

# Short, subtle reverb
python main.py --feedback_gain 0.7 --wet 0.3 --damp 0.4

# Custom delay configuration
python main.py --delays_ms 15 23 31 47 59 67 73 83
```

## Parameters

### FDNReverb Parameters

- `sr` (int): Sample rate in Hz
- `delays_ms` (tuple): Delay times in milliseconds. Use coprime/prime numbers for better diffusion
- `feedback_gain` (float, 0~1): Feedback gain. Larger values = longer reverb tail. Must be < 1.0
- `damp` (float, 0~1): Damping factor. Larger values = faster high-frequency decay
- `wet` (float, 0~1): Wet/dry mix ratio (0 = dry, 1 = fully wet)
- `mod_depth_ms` (float): Modulation depth in milliseconds. Light modulation avoids metallic artifacts
- `mod_rate_hz` (float): Modulation rate in Hz
- `output_gain` (float): Output gain scaling factor (default: 1.0)

### Number of Delay Lines

**Important Constraint**: The number of delay lines must be a **power of 2** (2, 4, 8, 16, 32, 64, etc.) because the Hadamard feedback matrix requires this. The default is **8 delay lines**.

**What happens if you add more delay lines?**

**Pros:**
- ‚úÖ **Richer, more complex reverb** - More delay lines create better diffusion and more echo paths
- ‚úÖ **Better spatial spread** - More paths for sound to travel through
- ‚úÖ **More realistic tails** - Denser echo patterns sound more natural

**Cons:**
- ‚ö†Ô∏è **Slower processing** - Feedback matrix multiplication is O(N¬≤), so 16 lines is ~4x slower than 8
- ‚ö†Ô∏è **More memory** - Each delay line needs its own buffer
- ‚ö†Ô∏è **Diminishing returns** - Beyond 16 lines, the improvement is often minimal

**Performance Impact:**
- **8 lines** (default): Baseline speed
- **16 lines**: ~2x slower
- **32 lines**: ~4x slower  
- **64 lines**: ~8x slower

**Recommendations:**
- **8 lines**: Good balance of quality and speed (default)
- **16 lines**: Richer reverb, ~2x slower - good for final mixes
- **32+ lines**: Usually not worth the slowdown unless you need maximum quality

**Example with 16 delay lines:**
```bash
python main.py --delays_ms 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83
```

**Note**: The code will raise an error if you provide a number of delay times that is not a power of 2.

## Performance

### Automatic Optimization

The code automatically tries to use the fastest available implementation:

1. **CPU C++ Extension**: Fast compiled C++ code, works on all platforms (auto-compiles on first run)
2. **Python Fallback**: Pure PyTorch implementation (slower but always works)

### Expected Performance

- **With C++ Extension**: 5-20x faster than Python
- **Processing Time** (tested on M4 MacBook Pro, CPU-only):
  - ~2.4 seconds for a 2-minute stereo song (with C++ extension)
  - ~1.2 seconds per minute of audio (approximately)
  - Python fallback is significantly slower (10-20x slower)

**Note**: FDN reverb is inherently sequential due to feedback loops, so each sample depends on previous samples. This provides unique sonic characteristics.

### Performance Tips

1. **Use C++ Extension**: The code automatically compiles and uses C++ extensions on first run
2. **Lower Sample Rate**: Processing at 44.1kHz instead of 48kHz is ~10% faster
3. **Adjust Block Size**: For very long files, consider processing in chunks

## Technical Details

### FDN Reverb Algorithm

This implementation follows the standard FDN (Feedback Delay Network) reverb structure:

Mathematically: `y[n] = A * y[n - delay] + g_in * x[n]`

Expanded form: `y[n] = g_fb * H * y[n - delay] + g_in * x[n]`

Where:
- `y[n]`: Output from delay lines at sample n
- `A`: Feedback matrix (`A = g_fb * H`)
- `H`: Orthogonal Hadamard matrix (satisfies `H^T * H = I`)
- `g_fb`: Feedback gain, a scaling factor (0~1) that controls reverb tail length and stability
- `y[n - delay]`: Previous samples from delay lines (with different delay lengths)
- `g_in`: Input gain (distributed across delay lines, `g_in = 1/N`)
- `x[n]`: Input signal

**Code Implementation** (in `reverb_util.py`):

1. **`y[n-delay]`** - Read from delay lines (line 121):
   ```python
   y_vec = torch.lerp(y0, y1, frac)  # (C, N) - reads from delay buffers
   ```

2. **`A * y[n-delay]`** - Feedback matrix multiplication (line 125):
   ```python
   fb = torch.einsum('ij,cj->ci', A, y_vec)  # A @ y_vec
   ```

3. **`g * x[n]`** - Input gain distribution (line 132):
   ```python
   in_vec = (x[:, n].unsqueeze(1) * input_div) * ones_vec.unsqueeze(0)  # g = 1/N
   ```

4. **`y[n] = A * y[n-delay] + g * x[n]`** - Write back to buffers (line 136):
   ```python
   buffers.scatter_(2, write_pos.unsqueeze(-1), (fb_damped + in_vec).unsqueeze(-1))
   ```
   Note: `fb_damped` includes damping filter (line 128) - an enhancement beyond basic FDN theory.

**Stability Requirement:**
The feedback matrix A must satisfy `A^T * A = I` (orthogonal), ensuring the feedback loop doesn't accumulate or explode energy over time.

**Implementation Details:**

1. **Orthogonal Feedback Matrix**: Uses **Hadamard matrix** (orthonormal, satisfies `A^T * A = I`)
   - Scaled by `feedback_gain` for stability: `A = feedback_gain * H` where `H` is Hadamard
   - This ensures `A^T * A = feedback_gain¬≤ * I`, which is stable when `feedback_gain < 1`

2. **Multiple Delay Lines**: Each delay line has a different length (coprime/prime numbers for better diffusion)

3. **Enhanced Features** (beyond basic FDN theory):
   - **Damping**: One-pole lowpass filter in feedback loop for realistic high-frequency decay
   - **Modulation**: Time-varying delays (LFO) to avoid metallic/comb artifacts
   - **Fractional Delay**: Linear interpolation for smooth delay line reading
   - **Input Distribution**: Input is divided equally across all delay lines (`g = 1/N`)

## Architecture

### File Structure

```
Reverb/
‚îú‚îÄ‚îÄ main.py              # Command-line interface and example usage script
‚îú‚îÄ‚îÄ reverb_util.py       # Main FDN reverb implementation
‚îú‚îÄ‚îÄ io_utils.py          # Audio I/O utilities (load/save MP3, WAV, etc.)
‚îú‚îÄ‚îÄ fdn_cpu.cpp          # CPU C++ extension (optional, auto-compiles)\
‚îî‚îÄ‚îÄ README.md           # This file
```

## Limitations

- FDN reverb is sequential (each sample depends on previous), so it can't be fully parallelized
- C++ extensions require compilation on first run (takes ~30-60 seconds)

## Acknowledgments

- **FDN reverb algorithm** based on the seminal paper:
  - Jot, J.-M., & Chaigne, A. (1991). "Digital delay networks for designing artificial reverberators." *AES Convention*. This paper introduced the Feedback Delay Network (FDN) structure and established the theoretical foundations for using orthogonal feedback matrices to create stable, realistic artificial reverberation.

## Reference

```
@inproceedings{jot1991digital,
  title={Digital delay networks for designing artificial reverberators},
  author={Jot, Jean-Marc and Chaigne, Antoine},
  booktitle={Audio Engineering Society Convention 90},
  year={1991},
  organization={Audio Engineering Society}
}
```
